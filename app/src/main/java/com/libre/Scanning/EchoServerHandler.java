package com.libre.Scanning;import android.util.Log;import com.cumulations.libreV2.model.SceneObject;import com.cumulations.libreV2.tcp_tunneling.TunnelingClientRunnable;import com.cumulations.libreV2.tcp_tunneling.TunnelingControl;import com.libre.luci.LSSDPNodeDB;import com.libre.luci.LSSDPNodes;import com.libre.luci.LUCIControl;import com.libre.netty.BusProvider;import com.libre.netty.NettyAndroidClient;import com.libre.netty.NettyClientHandler;import com.libre.util.LibreLogger;import org.jboss.netty.buffer.ChannelBuffer;import org.jboss.netty.channel.ChannelHandlerContext;import org.jboss.netty.channel.ChannelStateEvent;import org.jboss.netty.channel.ChildChannelStateEvent;import org.jboss.netty.channel.ExceptionEvent;import org.jboss.netty.channel.MessageEvent;import org.jboss.netty.channel.SimpleChannelHandler;import java.io.IOException;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.Socket;public class EchoServerHandler extends SimpleChannelHandler {    public ScanningHandler m_scanHandler = ScanningHandler.getInstance();    public NettyClientHandler handler;    @Override    public void childChannelClosed(ChannelHandlerContext ctx, ChildChannelStateEvent e) throws Exception {        super.childChannelClosed(ctx, e);    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)            throws Exception {        // TODO Auto-generated method stub        //super.exceptionCaught(ctx, e);        System.out.println(" EXCEPTION CaUGHT ++ " + e.getCause().toString());        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(this, "Exception  Caught For the Ip " + address.getHostAddress() + "as" + e.getCause().getMessage());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }/*        Channel ch = e.getChannel();        ch.close();*/    }    @Override    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelConnected(ctx, e);        InetAddress address = null;        if (e.getChannel().getRemoteAddress() instanceof InetSocketAddress) {            Log.d("LSSDP", "socket connected successfully");            address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();            LibreLogger.d(this, "Channel Connected For the Ip " + address.getHostAddress()                    +                    "for the Channel id is " + ctx.getChannel().getId());            ctx.getChannel().getConfig().setOption("child.keepAlive", true);            ctx.getChannel().getConfig().setOption("child.reuseaddress", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            handler = new NettyClientHandler(address.getHostAddress());        } else {            Log.d("LSSDP", "socket NOT connected successfully");        }    }    @Override    public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelDisconnected(ctx, e);        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(this, "Channel Disconnected For the Ip " + address.getHostAddress()                +                "for the Channel id is " + e.getChannel().getId());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }    }    @Override    public void closeRequested(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.closeRequested(ctx, e);    }    @Override    public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {        super.channelClosed(ctx, e);        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LibreLogger.d(this, "Channel Closed For the Ip " + address.getHostAddress() +                "for the Channel id is " + e.getChannel().getId());        if (LUCIControl.channelHandlerContextMap.containsKey(address.getHostAddress())) {            if (isChannelToBeRemovedFromTheChannelHandlerMap(ctx, address.getHostAddress())) {                LUCIControl.channelHandlerContextMap.get(address.getHostAddress()).getChannel().close();                LUCIControl.channelHandlerContextMap.remove(address.getHostAddress());            }        }    }    @Override    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)            throws Exception {        // TODO Auto-generated method stub        InetAddress address = null;        address = ((InetSocketAddress) e.getChannel().getRemoteAddress()).getAddress();        LUCIControl.channelHandlerContextMap.put("" + address.getHostAddress(), ctx);        LibreLogger.d(this, "Response Message Received ");        ChannelBuffer mChannelBufferMessageReceived = (ChannelBuffer) e.getMessage();        LibreLogger.d(this, "Response Message Received  +Successfull");        /// e.getChannel().close();        String mSearchMessageReceivedFromResponse = new String(mChannelBufferMessageReceived.array());        LibreLogger.d(this, "Response Received From Speaker " + e.getRemoteAddress() + "\tFrom Port Number" +                ctx.getChannel().getRemoteAddress() + "\tand Message is " +                mSearchMessageReceivedFromResponse);        /* We have to Store Only NOTIFY HandlerContext */        if (mSearchMessageReceivedFromResponse.contains("NOTIFY")) {            LibreLogger.d(this, "Notify is updating For the IpAddress " + address.getHostAddress()                    +                    "for the Channel id is " + ctx.getChannel().getId());            ctx.getChannel().getConfig().setOption("child.keepAlive", true);            ctx.getChannel().getConfig().setOption("child.reuseaddress", true);            ctx.getChannel().getConfig().setOption("child.tcpNoDelay", true);            LUCIControl.channelHandlerContextMap.put(address.getHostAddress(), ctx);        }        LSSDPNodes node = m_scanHandler.getLSSDPNodeFromMessage(e.getRemoteAddress(), mSearchMessageReceivedFromResponse);        if (node == null)            return;        /**LatestDiscoveryChanges         * Which means we are getting notification for first time hence we should remove old one and recreate it*/        CreateOrUpdateMyNewDevice(node);    }    private void CreateOrUpdateMyNewDevice(LSSDPNodes mInputNode) {        if (LUCIControl.luciSocketMap.containsKey(mInputNode.getIP())) {            NettyAndroidClient mExistingAndroidClient = LUCIControl.luciSocketMap.get(mInputNode.getIP());            /*Socket is Already Exists*/            if (mInputNode.getFirstNotification() != null && mInputNode.getFirstNotification().equals("1") && (System.currentTimeMillis() - mExistingAndroidClient.getCreationTime()) > 5000) {                LibreLogger.d(this, "In Create Or Update My New Device for the FirstNotification is 1 and CreationTimeMills's Difference is 5s for Ipaddress --> " + mInputNode.getIP() +                        "And Name of the Device is " + mInputNode.getFriendlyname());                /**closing existing NettyAndroidClient */                LUCIControl.luciSocketMap.get(mInputNode.getIP()).closeSocket();                LUCIControl.luciSocketMap.remove(mInputNode.getIP());                /* I will remove previous Socket Information */                RemovingTheCorrespondingSceneMapFromCentralDB(mInputNode);                NettyAndroidClient nettyAndroidClient = null;                try {                    nettyAndroidClient = new NettyAndroidClient(mInputNode.getNodeAddress(), 7777);                } catch (Exception e) {                    e.printStackTrace();                }                LUCIControl.luciSocketMap.put(mInputNode.getIP(), nettyAndroidClient);                LUCIControl control = new LUCIControl(mInputNode.getIP());                control.sendAsynchronousCommandSpecificPlaces();                LSSDPNodeDB lssdpNodeDB = LSSDPNodeDB.getInstance();                LSSDPNodes theNodeBasedOnTheIpAddress = lssdpNodeDB.getTheNodeBasedOnTheIpAddress(mInputNode.getIP());                if (theNodeBasedOnTheIpAddress != null && theNodeBasedOnTheIpAddress.getgCastVerision() != null) {                    // sleep                    try {                        Thread.sleep(250);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            } else {                LibreLogger.d(this, "In Create Or Update My New Device for the FirstNotification is 0 or CreationTimeMills's Difference is less than 5s for Ipaddress --> " + mInputNode.getIP() +                        "And Name of the Device is " + mInputNode.getFriendlyname());                NettyAndroidClient nettyAndroidClient = LUCIControl.luciSocketMap.get(mInputNode.getIP());                nettyAndroidClient.setLastNotifiedTime(System.currentTimeMillis());                LUCIControl.luciSocketMap.put(mInputNode.getIP(), nettyAndroidClient);            }        } else {            LibreLogger.d(this, "In Create Or Update My New Device for the LuciSocket is Not " +                    "availabe for the ipddress --> " + mInputNode.getIP() +                    "And Name of the Device is " + mInputNode.getFriendlyname());            /* Socket is Not Avaiable*/            LUCIControl.luciSocketMap.put(mInputNode.getIP(), NettyAndroidClient.getDummyInstance());            LibreLogger.d(this, "Socket Creating for Ip " + mInputNode.getIP() + " as a DummyInstance ");            try {                NettyAndroidClient tcpSocketSendCtr = new NettyAndroidClient(mInputNode.getNodeAddress(), 7777);                LibreLogger.d(this, "Socket Created for Ip " + mInputNode.getIP() + " Printing From NettyAndroidClient Socket  " + tcpSocketSendCtr.getRemotehost());                //if(tcpSocketSendCtr.isSocketCreated())                {                    tcpSocketSendCtr.setLastNotifiedTime(System.currentTimeMillis());                    LUCIControl.luciSocketMap.put(mInputNode.getIP(), tcpSocketSendCtr);                    LUCIControl control = new LUCIControl(mInputNode.getIP());                    control.sendAsynchronousCommandSpecificPlaces();                    LSSDPNodeDB lssdpNodeDB = LSSDPNodeDB.getInstance();                    LSSDPNodes theNodeBasedOnTheIpAddress = lssdpNodeDB.getTheNodeBasedOnTheIpAddress(mInputNode.getIP());                    if (theNodeBasedOnTheIpAddress != null && theNodeBasedOnTheIpAddress.getgCastVerision() != null) {                        // sleep                        try {                            Thread.sleep(250);                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    /*sending asynchronous command*/                    /* Anyway we have already sent the SendAsyn When Socket is Created So , Dont need to send onemoretime its a Bug*/                    // new LUCIControl(mInputNode.getIP()).sendAsynchronousCommandSpecificPlaces();                    LibreLogger.d(this, "Socket Created for Ip 2 " + mInputNode.getIP() + " Printing From NettyAndroidClient Socket  " + tcpSocketSendCtr.getRemotehost());                }            } catch (Exception e1) {                e1.printStackTrace();                LibreLogger.d(this, "Socket creation Failed in EchoServerHandler " + mInputNode.getIP());                LUCIControl.luciSocketMap.remove(mInputNode.getIP());                Log.e("Scan_Netty", "Socket creation not required in  EchoServerHandler" + mInputNode.getIP());            }        }        /* Checking Dupicates Irrespective of Socket is Available or not         * */        if ((mInputNode != null) && (mInputNode.getIP() != null) && (mInputNode.getDeviceState() != null) &&                (!m_scanHandler.findDupicateNode(mInputNode))) {            LibreLogger.d(this, "New Node is Found For the ipAddress " + mInputNode.getIP());            if (!mInputNode.getUSN().isEmpty()) {                BusProvider.getInstance().post(mInputNode);                m_scanHandler.lssdpNodeDB.addToNodeDb(mInputNode);                ScanningHandler mScanHandler = ScanningHandler.getInstance();                SceneObject sceneObjec = new SceneObject(" ", "", 0, mInputNode.getIP());                if (!mScanHandler.isIpAvailableInCentralSceneRepo(mInputNode.getIP())) {                    mScanHandler.putSceneObjectToCentralRepo(mInputNode.getIP(), sceneObjec);                }            } else {                LibreLogger.d(this, "USN is Empty " + mInputNode.getIP());            }        }        createOrUpdateTunnelingClients(mInputNode);    }    private boolean isChannelToBeRemovedFromTheChannelHandlerMap(ChannelHandlerContext ctx, String mIpAddress) {        if (ctx.getChannel().getId().equals(LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId())) {            LibreLogger.d(this, "EchoServerHandler" + "Channel is broken " + mIpAddress + "id as "                    + ctx.getChannel().getId() + "but its  Matched with " +                    LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId()            );            return true;        } else {            LibreLogger.d(this, "EchoServerHandler" + "Channel is broken " + mIpAddress + "id as "                    + ctx.getChannel().getId() + "but its Not Matched with " +                    LUCIControl.channelHandlerContextMap.get(mIpAddress).getChannel().getId()            );            return false;        }    }    private void RemovingTheCorrespondingSceneMapFromCentralDB(LSSDPNodes mNode) {        String mIpAddress = mNode.getIP();        LSSDPNodeDB mNodeDB = LSSDPNodeDB.getInstance();        try {            if (ScanningHandler.getInstance().isIpAvailableInCentralSceneRepo(mIpAddress)) {                boolean status = ScanningHandler.getInstance().removeSceneMapFromCentralRepo(mIpAddress);                LibreLogger.d(this, "Removing the Corresponding SceneMap Fro CentralDB status is " + status + " For the ip is " + mIpAddress);            }        } catch (Exception e) {            LibreLogger.d(this, "Removing the Corresponding SceneMap Fro CentralDB status" + "Removal Exception ");        }        mNodeDB.clearNode(mIpAddress);    }    private void createOrUpdateTunnelingClients(final LSSDPNodes mInputNode) {        /* It will not Wait for Socket to be created */        if (TunnelingControl.isTunnelingClientPresent(mInputNode.getIP())) {            Socket mExistingSocket = TunnelingControl.getTunnelingClient(mInputNode.getIP());            /*Socket is Already Exists*/            if (!mExistingSocket.isConnected()) {                TunnelingControl.removeTunnelingClient(mInputNode.getIP());                new Thread(new TunnelingClientRunnable(mInputNode.getIP())).start();            }        } else {            try {                new Thread(new TunnelingClientRunnable(mInputNode.getIP())).start();            } catch (Exception e) {                e.printStackTrace();                LibreLogger.d(this, "createOrUpdateTunnelingClients, exception = " + e.getMessage());            }        }    }}